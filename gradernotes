In this homework, we have dealt with semaphores, concurrent tasks and shared variables. 
Different from Tanenbaum's solution, which gives reader priority, we used another method which gives fair priority to both reader and writer.
The implementation is in P3helper.c. I have commented out for each line. Here I would illustrate how it works. Rather than in Tanenbaum's solution,in which if some reader process is trying to access the resource, then this process eventually succeeds, or another solution which gives priority to writer. In our solution, if some process is trying to access the resource, then this process eventually succeeds. We have defined two semaphores in p3helper.c, mutex and resources. Semaphore mutex is used to guard access to readers and writers varibale which are used to count the number of reader and writer. Semaphore resources is used to guard access to shared resources, that is database. In the initstudentsstuff, I have initialize two semaphores and two global varibale readers and writers to be 0. In prolog, which function is to get permission to the database, I have considered two cases. One is when writer calls, then writers should increase by 1, and also need to request for the shared resources access. After gaining the access to database, the epilog would release the resources, and the would decrease the writers variable. If he database is busy, the prolog would wait resources. If the reader calls, when KIND == 0, a reader executes wait resources only if it is the first reader(reader == 0) trying to gain the shared resources, or if a writer calls is trying to gain the access to the shared resources. (writers > 0). If the first reader is trying and the resources is available, the wait resources would allow it to proceed locking out. All subsequent readers will skip the if(writers > 0 || readers == 0) statement as long as there is no writer calls. Here the solution would allow several readers to access the resources simultaneously. However, if a writer calls to use the resources, it will be forced to wait. At the same time, all sebsequent readers will be forced to execute if(wr    iters > 0 || readers == 0) statement and wait for the resources too. Eventually, all readers which are before the waiting writer calls would finish their reading shared resources and release the access to share resources by "if(readers == 0)", then the waiting writer would proceed.
This program would give fairness to both reader and writer, which allow several reader reading database simultaneously. If a writer requests for access to the database, then it would run after all the reader before it have finished, which means the writer does not need to wait too long. The same thing applies to the readers. The readers does not need to wait too long for the finish of all writer process.
